<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Implementation Details on PositionPal</title><link>https://position-pal.github.io/docs/5-implementation/</link><description>Recent content in Implementation Details on PositionPal</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://position-pal.github.io/docs/5-implementation/index.xml" rel="self" type="application/rss+xml"/><item><title>Implementation details for common services</title><link>https://position-pal.github.io/docs/5-implementation/0-common/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://position-pal.github.io/docs/5-implementation/0-common/</guid><description>&lt;h2 id="message-broker-and-rpc-technologies">Message Broker and RPC technologies &lt;a href="#message-broker-and-rpc-technologies" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Why RabbitMQ?
Why gRPC?&lt;/p>
&lt;p>**
tecnologie
tipologia
**
TODO - GIOVA&lt;/p>
&lt;h2 id="gateway">Gateway &lt;a href="#gateway" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The gateway is the entry point of the system and is the only service that is exposed to the outside world.
Their main responsibilities and features are:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>routing each request to the correct service after having authenticated and authorized the user&lt;/strong>: it is important that only authenticated users can access the services and that they can only access the functionalities they are allowed to use. For example, a user can only access the functionalities of the group they belong to.&lt;/li>
&lt;li>&lt;strong>protocol translation&lt;/strong>: for &lt;em>synchronous&lt;/em> remote procedure calls it is a best practice to use a ReST based API over the chosen gRPC protocol. This is because ReST APIs can be easily consumed by any client since they leverage standard HTTP methods and formats (like JSON), while gRPC APIs are more efficient but require specialized client libraries to handle Protobuf messages and HTTP/2 connections.&lt;/li>
&lt;li>since it is the entry-point of the system it can be a single point of failure and a bottleneck. To avoid this it is implemented like a &lt;strong>stateless service&lt;/strong>, so it can be easily scaled horizontally to handle more requests and to be fault-tolerant.&lt;/li>
&lt;/ul>
&lt;pre class="mermaid">flowchart RL
 client[Client Applications] --&amp;gt;|HTTP/REST| gateway[API Gateway]
 
 subgraph gateway_components[API Gateway Components]
 auth[Authentication]
 authoriz[Authorization]
 router[Request Router]
 translator[Protocol Translator]
 response_translator[Response Translator]
 end
 
 gateway --&amp;gt; auth
 auth --&amp;gt; authoriz
 authoriz --&amp;gt; router
 router --&amp;gt; translator
 
 translator --&amp;gt;|gRPC| serviceA[Location Service \n REST API]
 translator --&amp;gt;|wss| serviceB[Location Service \n Websocket API]
 translator --&amp;gt;|gRPC| serviceC[User Service \n gRPC API]
 translator --&amp;gt;|gRPC| serviceD[Chat Service \n gRPC API]
 translator --&amp;gt;|wss| serviceE[Chat Service \n Websocket API]
 translator --&amp;gt;|gRPC| serviceF[Notification Service \n gRPC API]

 
 serviceA .-&amp;gt; response_translator
 serviceB .-&amp;gt; response_translator
 serviceC .-&amp;gt; response_translator
 serviceD .-&amp;gt; response_translator
 serviceE .-&amp;gt; response_translator
 serviceF .-&amp;gt; response_translator
 
 response_translator --&amp;gt;|HTTP/REST| gateway
 gateway --&amp;gt;|HTTP/REST| client
 
 classDef gateway fill:#f96,stroke:#333,stroke-width:2px
 classDef client fill:#9d9,stroke:#333,stroke-width:1px
 classDef component fill:#fcf,stroke:#333,stroke-width:1px
 
 class gateway gateway
 class client client
 class auth,router,translator,authoriz,response_translator component
&lt;/pre>
&lt;p>The API Gateway is implemented using &lt;strong>Express&lt;/strong>, a lightweight and flexible &lt;em>Node.js&lt;/em> framework that simplifies the creation of web applications and APIs.&lt;/p></description></item><item><title>User and Group Service implementation details</title><link>https://position-pal.github.io/docs/5-implementation/4-user-groupd-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://position-pal.github.io/docs/5-implementation/4-user-groupd-service/</guid><description>&lt;p>This chapter provides an overview of the implementation details of the &lt;strong>User and Group Service&lt;/strong>.&lt;/p>
&lt;h2 id="high-level-overview-and-modules-structure">High level overview and modules structure &lt;a href="#high-level-overview-and-modules-structure" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The User and Group Service is responsible for managing the users and groups of the system. It is a core service that is used by other services to manage the users and groups of the system.&lt;/p>
&lt;p>The User and Group Service is composed of the following modules:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>User Management Module&lt;/strong>: This module is responsible for managing the users of the system. It provides APIs for creating, updating, deleting, and retrieving user information.&lt;/p></description></item><item><title>Location Service implementation details</title><link>https://position-pal.github.io/docs/5-implementation/1-location-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://position-pal.github.io/docs/5-implementation/1-location-service/</guid><description>&lt;p>This chapter provides an overview of the implementation details of the &lt;strong>Location Service&lt;/strong>.&lt;/p>
&lt;h2 id="user-tracking-and-real-time-management">User Tracking and Real-time Management &lt;a href="#user-tracking-and-real-time-management" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The most important and critical feature of the Location Service is the &lt;strong>tracking&lt;/strong> of the user&amp;rsquo;s location and real-time management of their state considering the high volume of data that needs to be processed in real-time.
Moreover, the service is in charge of the user monitoring during the &lt;em>SOS&lt;/em> and &lt;em>Routing&lt;/em> modes, which require to take real-time actions to ensure the user&amp;rsquo;s safety.&lt;/p></description></item><item><title>Chat Service implementation details</title><link>https://position-pal.github.io/docs/5-implementation/3-chat-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://position-pal.github.io/docs/5-implementation/3-chat-service/</guid><description>&lt;h2 id="chat-messaging-and-real-time-management">Chat Messaging and Real-time Management &lt;a href="#chat-messaging-and-real-time-management" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The primary functions of the chat service are to manage the &lt;em>chat groups&lt;/em> and the relative &lt;em>messages&lt;/em> that are exchanged between users of these groups.
In most of the cases the amount of messages exchanged is high, and the service needs to manage them in real-time with low latency of response.&lt;/p>
&lt;p>We built a &lt;strong>WebSocket-based&lt;/strong> communication system using an actor model. Specifically, we leveraged the &lt;strong>Event Sourcing&lt;/strong> module from the &lt;em>Akka framework&lt;/em> to handle Group instances. This approach treats Events as first-class citizens while maintaining consistent chat state.&lt;/p></description></item><item><title>Notification Service implementation details</title><link>https://position-pal.github.io/docs/5-implementation/2-notification-service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://position-pal.github.io/docs/5-implementation/2-notification-service/</guid><description>&lt;!--## High level overview and modules structure-->
&lt;p>Currently, the only supported notification types are &lt;strong>push notifications&lt;/strong>, which are essential to guarantee that the client is immediately informed about groups changes or user state changes, like the trigger of the SOS alert or the journey start.&lt;/p>
&lt;!--

&lt;div style="width: 100%; overflow-x: auto; white-space: nowrap;">
 &lt;img 
 src="https://position-pal.github.io/res/repo-structure-light.svg" 
 alt="repo-structure schema" 
 style="max-width: 1100px;"
 class="schema"
 />
&lt;/div>


-->
&lt;h2 id="notification-commands">Notification commands &lt;a href="#notification-commands" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Like already presented in the &lt;a href="https://position-pal.github.io/docs/3-arch-design/2-architecture-design/">Architecture Design&lt;/a> section, the notification service is integrated with the message broker to receive notification commands from other microservices.&lt;/p></description></item></channel></rss>